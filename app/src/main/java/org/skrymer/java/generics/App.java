/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package org.skrymer.java.generics;

import java.util.ArrayList;
import java.util.List;

public class App {

    public static void main(String[] args) {
        var dogTrainer = new DogTrainer();
        var unsafeDogs = new ArrayList();
        unsafeDogs.add(new Dog());
        //dogs.add(new Cat()); - will fail at runtime
        dogTrainer.unsafeTrain(unsafeDogs);

        var safeDogs = new ArrayList<Dog>();
        safeDogs.add(new Dog());
        // safeDogs.add(new Cat()); - will fail at compile time
        dogTrainer.safeTrain(safeDogs);

        // List<T>
        // var bList = new ArrayList<B>();
        // // bList.add(new A()); - not allowed to add A as not a B
        // bList.add(new B());
        // bList.add(new C()); // - ok as C is a B
        // System.out.println(bList.get(0));
        // System.out.println(bList.get(1));

        // List<? extends T>
        // var bList = new ArrayList<B>();
        // List<? extends A> aList = bList; // ok as bList contains B which extends A
        // // bList.add(new A()); not possible as the original list contains B's    
        // bList.add(new B()); // ok to add B here as the original reference is still in scope, the compiler knows it's a list of B's
        // var cList = new ArrayList<C>(); // ok as the C extends B
        // addToList(cList);

        // List<? super T>
        var bList = new ArrayList<B>();
        List<? super B> someList = bList;
        // not possible as the original list contains B's    
        // bList.add(new A()); 
        someList.add(new B());
        someList.add(new C());
        addToList2(someList);
        
        var aList = new ArrayList<A>();
        addToList2(aList);
        
        // cant add as C is not a parrent of B
        // var cList = new ArrayList<C>();        
        // addToList2(cList);
    }

    public static void addToList(List<? extends B> list){
        // -- not possible as the original reference is no longer in scope
        // for instance we could pass in a list of C 
        // list.add(new B()); 

        // ok to read from the list, but not add
        for(B b : list){
            System.out.println(b);
        }
    }

    public static void addToList2(List<? super B> list){
        // ok to add as the list contains a B or children of B
        list.add(new B()); 
        list.add(new C());
        // safe to reference Object as nothing extends Object - we know it's an Object
        for(Object b : list){
            System.out.println(b);
        }
    }    
}
